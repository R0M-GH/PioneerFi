import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/highcharts/modules/broken-axis.js
var require_broken_axis = __commonJS({
  "node_modules/highcharts/modules/broken-axis.js"(exports, module) {
    "use strict";
    (function(f) {
      typeof module === "object" && module.exports ? (f["default"] = f, module.exports = f) : typeof define === "function" && define.amd ? define("highcharts/modules/broken-axis", ["highcharts"], function(l) {
        f(l);
        f.Highcharts = l;
        return f;
      }) : f(typeof Highcharts !== "undefined" ? Highcharts : void 0);
    })(function(f) {
      function l(f2, h, n, l2) {
        f2.hasOwnProperty(h) || (f2[h] = l2.apply(null, n));
      }
      f = f ? f._modules : {};
      l(f, "Core/Axis/BrokenAxis.js", [f["Extensions/Stacking.js"], f["Core/Utilities.js"]], function(f2, h) {
        var n = h.addEvent, l2 = h.find, x = h.fireEvent, z = h.isArray, m = h.isNumber, u = h.pick, v;
        (function(h2) {
          function v2() {
            typeof this.brokenAxis !== "undefined" && this.brokenAxis.setBreaks(this.options.breaks, false);
          }
          function A() {
            this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = false);
          }
          function B() {
            var c = this.brokenAxis;
            if (c && c.hasBreaks) {
              for (var b = this.tickPositions, g = this.tickPositions.info, e = [], a = 0; a < b.length; a++)
                c.isInAnyBreak(b[a]) || e.push(b[a]);
              this.tickPositions = e;
              this.tickPositions.info = g;
            }
          }
          function C() {
            this.brokenAxis || (this.brokenAxis = new y(this));
          }
          function D() {
            var c = this.options.connectNulls, b = this.points, g = this.xAxis, e = this.yAxis;
            if (this.isDirty)
              for (var a = b.length; a--; ) {
                var d = b[a], f3 = !(d.y === null && c === false) && (g && g.brokenAxis && g.brokenAxis.isInAnyBreak(d.x, true) || e && e.brokenAxis && e.brokenAxis.isInAnyBreak(d.y, true));
                d.visible = f3 ? false : d.options.visible !== false;
              }
          }
          function E() {
            this.drawBreaks(this.xAxis, ["x"]);
            this.drawBreaks(this.yAxis, u(this.pointArrayMap, ["y"]));
          }
          function F(c, b) {
            var g = this, e = g.points, a, d, f3, k;
            if (c && c.brokenAxis && c.brokenAxis.hasBreaks) {
              var h3 = c.brokenAxis;
              b.forEach(function(b2) {
                a = h3 && h3.breakArray || [];
                d = c.isXAxis ? c.min : u(g.options.threshold, c.min);
                e.forEach(function(e2) {
                  k = u(e2["stack" + b2.toUpperCase()], e2[b2]);
                  a.forEach(function(a2) {
                    if (m(d) && m(k)) {
                      f3 = false;
                      if (d < a2.from && k > a2.to || d > a2.from && k < a2.from)
                        f3 = "pointBreak";
                      else if (d < a2.from && k > a2.from && k < a2.to || d > a2.from && k > a2.to && k < a2.from)
                        f3 = "pointInBreak";
                      f3 && x(c, f3, { point: e2, brk: a2 });
                    }
                  });
                });
              });
            }
          }
          function G() {
            var c = this.currentDataGrouping, b = c && c.gapSize;
            c = this.points.slice();
            var g = this.yAxis, e = this.options.gapSize, a = c.length - 1, d;
            if (e && 0 < a)
              for (this.options.gapUnit !== "value" && (e *= this.basePointRange), b && b > e && b >= this.basePointRange && (e = b), d = void 0; a--; )
                d && d.visible !== false || (d = c[a + 1]), b = c[a], d.visible !== false && b.visible !== false && (d.x - b.x > e && (d = (b.x + d.x) / 2, c.splice(a + 1, 0, { isNull: true, x: d }), g.stacking && this.options.stacking && (d = g.stacking.stacks[this.stackKey][d] = new f2(g, g.options.stackLabels, false, d, this.stack), d.total = 0)), d = b);
            return this.getGraphPath(c);
          }
          var w = [];
          h2.compose = function(c, b) {
            w.indexOf(c) === -1 && (w.push(c), c.keepProps.push("brokenAxis"), n(c, "init", C), n(c, "afterInit", v2), n(c, "afterSetTickPositions", B), n(c, "afterSetOptions", A));
            if (w.indexOf(b) === -1) {
              w.push(b);
              var g = b.prototype;
              g.drawBreaks = F;
              g.gappedPath = G;
              n(b, "afterGeneratePoints", D);
              n(b, "afterRender", E);
            }
            return c;
          };
          var y = function() {
            function c(b) {
              this.hasBreaks = false;
              this.axis = b;
            }
            c.isInBreak = function(b, c2) {
              var e = b.repeat || Infinity, a = b.from, d = b.to - b.from;
              c2 = c2 >= a ? (c2 - a) % e : e - (a - c2) % e;
              return b.inclusive ? c2 <= d : c2 < d && c2 !== 0;
            };
            c.lin2Val = function(b) {
              var g = this.brokenAxis;
              g = g && g.breakArray;
              if (!g || !m(b))
                return b;
              var e;
              for (e = 0; e < g.length; e++) {
                var a = g[e];
                if (a.from >= b)
                  break;
                else
                  a.to < b ? b += a.len : c.isInBreak(a, b) && (b += a.len);
              }
              return b;
            };
            c.val2Lin = function(b) {
              var g = this.brokenAxis;
              g = g && g.breakArray;
              if (!g || !m(b))
                return b;
              var e = b, a;
              for (a = 0; a < g.length; a++) {
                var d = g[a];
                if (d.to <= b)
                  e -= d.len;
                else if (d.from >= b)
                  break;
                else if (c.isInBreak(d, b)) {
                  e -= b - d.from;
                  break;
                }
              }
              return e;
            };
            c.prototype.findBreakAt = function(b, c2) {
              return l2(c2, function(c3) {
                return c3.from < b && b < c3.to;
              });
            };
            c.prototype.isInAnyBreak = function(b, g) {
              var e = this.axis, a = e.options.breaks || [], d = a.length, f3;
              if (d && m(b)) {
                for (; d--; )
                  if (c.isInBreak(a[d], b)) {
                    var k = true;
                    f3 || (f3 = u(a[d].showPoints, !e.isXAxis));
                  }
                var h3 = k && g ? k && !f3 : k;
              }
              return h3;
            };
            c.prototype.setBreaks = function(b, f3) {
              var e = this, a = e.axis, d = z(b) && !!b.length;
              a.isDirty = e.hasBreaks !== d;
              e.hasBreaks = d;
              a.options.breaks = a.userOptions.breaks = b;
              a.forceRedraw = true;
              a.series.forEach(function(a2) {
                a2.isDirty = true;
              });
              d || a.val2lin !== c.val2Lin || (delete a.val2lin, delete a.lin2val);
              d && (a.userOptions.ordinal = false, a.lin2val = c.lin2Val, a.val2lin = c.val2Lin, a.setExtremes = function(b2, c2, d2, f4, g) {
                if (e.hasBreaks) {
                  for (var h3 = this.options.breaks || [], k; k = e.findBreakAt(b2, h3); )
                    b2 = k.to;
                  for (; k = e.findBreakAt(c2, h3); )
                    c2 = k.from;
                  c2 < b2 && (c2 = b2);
                }
                a.constructor.prototype.setExtremes.call(this, b2, c2, d2, f4, g);
              }, a.setAxisTranslation = function() {
                a.constructor.prototype.setAxisTranslation.call(this);
                e.unitLength = void 0;
                if (e.hasBreaks) {
                  var b2 = a.options.breaks || [], d2 = [], f4 = [], g = u(a.pointRangePadding, 0), h3 = 0, r, p = a.userMin || a.min, t = a.userMax || a.max, l3;
                  b2.forEach(function(a2) {
                    r = a2.repeat || Infinity;
                    m(p) && m(t) && (c.isInBreak(a2, p) && (p += a2.to % r - p % r), c.isInBreak(a2, t) && (t -= t % r - a2.from % r));
                  });
                  b2.forEach(function(a2) {
                    q = a2.from;
                    r = a2.repeat || Infinity;
                    if (m(p) && m(t)) {
                      for (; q - r > p; )
                        q -= r;
                      for (; q < p; )
                        q += r;
                      for (l3 = q; l3 < t; l3 += r)
                        d2.push({ value: l3, move: "in" }), d2.push({ value: l3 + a2.to - a2.from, move: "out", size: a2.breakSize });
                    }
                  });
                  d2.sort(function(a2, b3) {
                    return a2.value === b3.value ? (a2.move === "in" ? 0 : 1) - (b3.move === "in" ? 0 : 1) : a2.value - b3.value;
                  });
                  var n2 = 0;
                  var q = p;
                  d2.forEach(function(a2) {
                    n2 += a2.move === "in" ? 1 : -1;
                    n2 === 1 && a2.move === "in" && (q = a2.value);
                    n2 === 0 && m(q) && (f4.push({ from: q, to: a2.value, len: a2.value - q - (a2.size || 0) }), h3 += a2.value - q - (a2.size || 0));
                  });
                  e.breakArray = f4;
                  m(p) && m(t) && m(a.min) && (e.unitLength = t - p - h3 + g, x(a, "afterBreaks"), a.staticScale ? a.transA = a.staticScale : e.unitLength && (a.transA *= (t - a.min + g) / e.unitLength), g && (a.minPixelPadding = a.transA * (a.minPointOffset || 0)), a.min = p, a.max = t);
                }
              });
              u(f3, true) && a.chart.redraw();
            };
            return c;
          }();
          h2.Additions = y;
        })(v || (v = {}));
        return v;
      });
      l(f, "masters/modules/broken-axis.src.js", [f["Core/Globals.js"], f["Core/Axis/BrokenAxis.js"]], function(f2, h) {
        h.compose(f2.Axis, f2.Series);
      });
    });
  }
});

// dep:highcharts_modules_broken-axis
var highcharts_modules_broken_axis_default = require_broken_axis();
export {
  highcharts_modules_broken_axis_default as default
};
//# sourceMappingURL=highcharts_modules_broken-axis.js.map
